// AskTech Chat Application

// Check authentication on page load
const token = localStorage.getItem('access_token');
console.log('ğŸ”‘ Token check on load:', token ? `Found: ${token.substring(0, 30)}...` : 'No token found');

if (!token) {
    console.log('No token found, redirecting to login...');
    window.location.href = '/login';
}

// Global variables
let historyEl;
let messageEl;
let sendBtn;
let speechBtn;
let languageSelect;
let logoutBtn;
let recognition = null;
let currentLanguage = 'ar-SA'; // Default to Arabic
let isSpeaking = false; // Flag to prevent multiple TTS calls

// Text-to-speech function
function speakText(text, lang) {
    // Prevent multiple simultaneous speech calls
    if (isSpeaking) {
        console.log('âš ï¸ Already speaking, ignoring new speech request');
        return; // IMPORTANT: Return early to prevent duplicate speech
    }
    
    // Sanitize text to avoid speaking markdown or bullet symbols like '*'
    const sanitizeForSpeech = (t) => {
        if (!t) return '';
        let s = t;
        // Remove markdown bold/italics markers
        s = s.replace(/\*\*(.*?)\*\*/g, '$1');
        s = s.replace(/\*(.*?)\*/g, '$1');
        s = s.replace(/_(.*?)_/g, '$1');
        // Convert markdown links [text](url) -> text
        s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '$1');
        // Strip leading bullets on each line: -, *, â€¢, or numeric like 1. / 1)
        s = s.split(/\r?\n/)
             .map(line => line.replace(/^\s*((?:[-â€¢*])|(?:\d+[\.)]))\s+/, ''))
             .join('\n');
        // Remove any leftover asterisks
        s = s.replace(/\*/g, '');
        // Remove markdown headings
        s = s.replace(/^\s*#{1,6}\s+/gm, '');
        // Collapse multiple spaces
        s = s.replace(/[ ]{2,}/g, ' ');
        return s.trim();
    };

    const cleanText = sanitizeForSpeech(text);
    if ('speechSynthesis' in window) {
        // Cancel any ongoing speech
        window.speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(cleanText);
        utterance.lang = lang;
        utterance.rate = 0.85; // Slightly slower for better clarity
        utterance.pitch = 1;
        utterance.volume = 1;
        
        // Load voices if not already loaded
        let voices = window.speechSynthesis.getVoices();
        
        // Try to find the best Arabic voice if speaking Arabic
        if (lang.startsWith('ar')) {
            // Prefer these Arabic voices in order
            const preferredVoices = [
                'Microsoft Hoda - Arabic (Saudi Arabia)',
                'Google Arabic',
                'Arabic Saudi Arabia',
                'ar-SA',
                'ar-EG'
            ];
            
            let arabicVoice = null;
            
            // Try to find preferred voices
            for (const preferred of preferredVoices) {
                arabicVoice = voices.find(voice => 
                    voice.name.includes(preferred) || voice.lang.startsWith('ar')
                );
                if (arabicVoice) break;
            }
            
            // Fallback to any Arabic voice
            if (!arabicVoice) {
                arabicVoice = voices.find(voice => voice.lang.startsWith('ar'));
            }
            
            if (arabicVoice) {
                utterance.voice = arabicVoice;
                console.log('Using Arabic voice:', arabicVoice.name);
            } else {
                console.warn('No Arabic voice found, using default');
            }
        }
        
        // Animate interviewer avatar while speaking
        const avatar = document.getElementById('interviewerAvatar');
        const onStart = () => { 
            isSpeaking = true;
            if (avatar) avatar.classList.add('speaking');
        };
        const onDone = () => {
            isSpeaking = false;
            if (avatar) avatar.classList.remove('speaking');
        };
        utterance.onstart = onStart;
        utterance.onend = onDone;
        utterance.onerror = onDone;

        window.speechSynthesis.speak(utterance);
    }
}

// Load chat history on page load
async function loadHistory() {
    const token = localStorage.getItem('access_token');
    if (!token) {
        console.log('No token found, redirecting to login...');
        window.location.href = '/login';
        return;
    }

    try {
        console.log('Loading history with token:', token.substring(0, 20) + '...');
        const response = await fetch('/api/history', {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });

        console.log('History response status:', response.status);

        if (response.status === 401 || response.status === 403) {
            // Token expired, invalid, or forbidden
            console.warn('Authentication failed, clearing token and redirecting...');
            localStorage.removeItem('access_token');
            localStorage.removeItem('user');
            window.location.href = '/login';
            return;
        }

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const messages = await response.json();
        
        console.log('Loaded messages:', messages.length);
        historyEl.innerHTML = '';
        messages.forEach(msg => {
            appendMessage(msg.role, msg.text);
        });
        
        // Scroll to bottom
        historyEl.scrollTop = historyEl.scrollHeight;
    } catch (error) {
        console.error('Error loading history:', error);
        appendMessage('system', 'âŒ Error loading chat history: ' + error.message);
    }
}

// Append message to history
function sanitizeForDisplay(t) {
    if (!t) return '';
    let s = t;
    // Remove markdown bold/italics markers
    s = s.replace(/\*\*(.*?)\*\*/g, '$1');
    s = s.replace(/\*(.*?)\*/g, '$1');
    s = s.replace(/_(.*?)_/g, '$1');
    // Convert markdown links [text](url) -> text
    s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '$1');
    // Strip markdown headings (leading #...)
    s = s.replace(/^\s*#{1,6}\s+/gm, '');
    // Remove any stray asterisks used as bullets
    s = s.replace(/^\s*\*/gm, '');
    // Collapse excessive spaces
    s = s.replace(/[ ]{2,}/g, ' ');
    return s.trim();
}

function createListFromText(text, lang) {
    const raw = text || '';
    const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    if (lines.length <= 1) return null;

    // Detect if lines are mostly bullets or numbers
    let bulletCount = 0, numberCount = 0;
    lines.forEach(l => {
        if (/^[-*â€¢]\s+/.test(l)) bulletCount++;
        else if (/^\d+[\.)]\s+/.test(l)) numberCount++;
    });

    const useBullets = bulletCount >= numberCount;
    const listEl = document.createElement(useBullets ? 'ul' : 'ol');
    if (lang && lang.startsWith('ar')) {
        listEl.setAttribute('dir', 'rtl');
    }

    lines.forEach(line => {
            let cleaned = line
                .replace(/^\s*((?:[-â€¢*])|(?:\d+[\.)]))\s+/, '') // bullet/number prefix
                .replace(/^\s*#{1,6}\s+/, '')                    // heading markers
                .replace(/\*\*(.*?)\*\*/g, '$1')               // bold
                .replace(/\*(.*?)\*/g, '$1')                     // italics
                .replace(/_(.*?)_/g, '$1')                         // underscore italics
                .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '$1')    // links
                .replace(/\*/g, '');                              // stray asterisks

        cleaned = cleaned.trim();
        if (!cleaned) return;
        const li = document.createElement('li');
        li.textContent = cleaned;
        listEl.appendChild(li);
    });

    return listEl.childElementCount ? listEl : null;
}

function appendMessage(role, text) {
    const msgDiv = document.createElement('div');
    msgDiv.className = `message ${role}`;
    
    // Create message content wrapper
    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';
    
    const roleLabel = document.createElement('strong');
    roleLabel.textContent = role === 'user' ? 'Ø£Ù†Øª: ' : 
                           role === 'assistant' ? 'AskTech: ' : 
                           'Ø§Ù„Ù†Ø¸Ø§Ù…: ';
    
    // For assistant replies, render as list (bullets or numbers) when multi-line
    const maybeList = role === 'assistant' ? createListFromText(text, currentLanguage) : null;
    if (maybeList) {
        contentDiv.appendChild(roleLabel);
        contentDiv.appendChild(maybeList);
    } else {
        const textSpan = document.createElement('span');
        // Sanitize visible text to remove '*' and '#' markdown symbols
        textSpan.textContent = role === 'assistant' ? sanitizeForDisplay(text) : text;
        contentDiv.appendChild(roleLabel);
        contentDiv.appendChild(textSpan);
    }
    msgDiv.appendChild(contentDiv);
    
    // Add speaker button for assistant messages
    if (role === 'assistant') {
        const speakerBtn = document.createElement('button');
        speakerBtn.className = 'speaker-btn';
        speakerBtn.textContent = 'ğŸ”Š';
        speakerBtn.title = 'Ø§Ø³ØªÙ…Ø§Ø¹ Ù„Ù„Ø±Ø¯';
        speakerBtn.onclick = () => speakText(text, currentLanguage);
        msgDiv.appendChild(speakerBtn);
    }
    
    historyEl.appendChild(msgDiv);
    
    // Scroll to bottom
    historyEl.scrollTop = historyEl.scrollHeight;
    
    // Auto-speak assistant messages if Arabic is selected
    if (role === 'assistant' && currentLanguage.startsWith('ar')) {
        speakText(text, currentLanguage);
    }
}

// Send message
async function sendMessage() {
    const message = messageEl.value.trim();
    if (!message) {
        return;
    }

    // Check token
    const token = localStorage.getItem('access_token');
    if (!token) {
        window.location.href = '/login';
        return;
    }

    // Disable input while processing
    messageEl.disabled = true;
    sendBtn.disabled = true;
    sendBtn.textContent = 'Sending...';

    // Show user message immediately
    appendMessage('user', message);
    messageEl.value = '';

    try {
        console.log('ğŸ“¤ Sending message to /api/chat...');
        const response = await fetch('/api/chat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({ message })
        });

        console.log('ğŸ“¥ Response status:', response.status);

        if (response.status === 401 || response.status === 403) {
            // Token expired or invalid
            console.warn('âŒ Authentication failed');
            localStorage.removeItem('access_token');
            localStorage.removeItem('user');
            window.location.href = '/login';
            return;
        }

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
            console.error('âŒ Server error:', errorData);
            throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        console.log('âœ… Response data:', data);
        
        // Show assistant response
        if (data.messages && data.messages.length > 0) {
            data.messages.forEach(msg => {
                appendMessage(msg.role, msg.text);
            });
        } else {
            console.warn('âš ï¸ No messages in response');
            appendMessage('system', 'âš ï¸ No response received from server');
        }
    } catch (error) {
        console.error('Error sending message:', error);
        
        // Better error message
        let errorMsg = error.message;
        if (errorMsg.includes('401')) {
            errorMsg = currentLanguage === 'ar-SA' ? 
                'Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø¬Ù„Ø³Ø©. Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙˆØ¬ÙŠÙ‡ Ù„Ù„Ø¯Ø®ÙˆÙ„...' : 
                'Session expired. Redirecting to login...';
            setTimeout(() => {
                localStorage.removeItem('access_token');
                localStorage.removeItem('user');
                window.location.href = '/login';
            }, 2000);
        }
        
        appendMessage('system', 'âŒ ' + (currentLanguage === 'ar-SA' ? 'Ø®Ø·Ø£: ' : 'Error: ') + errorMsg);
    } finally {
        // Re-enable input
        messageEl.disabled = false;
        sendBtn.disabled = false;
        sendBtn.textContent = 'Send';
        messageEl.focus();
    }
}

// Initialize application when DOM is loaded
window.addEventListener('DOMContentLoaded', () => {
    // Initialize DOM elements
    historyEl = document.getElementById('history');
    messageEl = document.getElementById('message');
    sendBtn = document.getElementById('send');
    speechBtn = document.getElementById('speech');
    languageSelect = document.getElementById('language');
    logoutBtn = document.getElementById('logoutBtn');
    // Menu items
    const menuInterview = document.getElementById('menuInterview');
    const menuRequirements = document.getElementById('menuRequirements');
    const menuTopJobs = document.getElementById('menuTopJobs');
    
    // Initialize speech recognition
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.interimResults = false;
        recognition.lang = currentLanguage;

        recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            messageEl.value = transcript;
            speechBtn.textContent = 'ğŸ¤';
        };

        recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            speechBtn.textContent = 'ğŸ¤';
            alert('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØª: ' + event.error);
        };

        recognition.onend = () => {
            speechBtn.textContent = 'ğŸ¤';
        };
    } else if (speechBtn) {
        speechBtn.disabled = true;
        speechBtn.title = 'Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØª ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ… ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù…ØªØµÙØ­';
    }
    
    // Event listeners
    if (sendBtn) {
        sendBtn.addEventListener('click', sendMessage);
    }

    if (messageEl) {
        messageEl.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
    }

    if (speechBtn) {
        speechBtn.addEventListener('click', () => {
            if (!recognition) {
                alert('Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØª ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ… ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù…ØªØµÙØ­');
                return;
            }

            if (speechBtn.textContent === 'ğŸ¤') {
                try {
                    recognition.start();
                    speechBtn.textContent = 'ğŸ”´';
                } catch (error) {
                    console.error('Error starting speech recognition:', error);
                    alert('Ø®Ø·Ø£ ÙÙŠ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØª: ' + error.message);
                }
            } else {
                recognition.stop();
                speechBtn.textContent = 'ğŸ¤';
            }
        });
    }

    // Menu actions: prefill the message box with helpful prompts
    if (menuInterview && messageEl) {
        menuInterview.addEventListener('click', () => {
            const ar = 'Ù…Ù† ÙØ¶Ù„Ùƒ Ø­Ø¶Ù‘Ø± Ù„ÙŠ Ø£Ø³Ø¦Ù„Ø© Ø´Ø§Ø¦Ø¹Ø© Ù„Ù…Ù‚Ø§Ø¨Ù„Ø© Ø¹Ù…Ù„ Ù„ÙˆØ¸ÙŠÙØ© [Ø§ÙƒØªØ¨ Ø§Ù„Ù…Ø³Ù…Ù‰ Ø§Ù„ÙˆØ¸ÙŠÙÙŠ Ù‡Ù†Ø§] Ù…Ø¹ Ø¥Ø¬Ø§Ø¨Ø§Øª Ù†Ù…ÙˆØ°Ø¬ÙŠØ© Ù…Ø®ØªØµØ±Ø©ØŒ ÙˆÙ†ØµØ§Ø¦Ø­ Ù…Ø®ØªØµØ±Ø© Ù„ÙƒÙ„ Ø³Ø¤Ø§Ù„.';
            const en = 'Please prepare common interview questions for the role of [job title] with brief model answers and short tips for each question.';
            messageEl.value = currentLanguage.startsWith('ar') ? ar : en;
            // Auto-send the request
            sendMessage();
        });
    }
    if (menuRequirements && messageEl) {
        menuRequirements.addEventListener('click', () => {
            const ar = 'Ù…Ø§ Ù‡ÙŠ Ù…ØªØ·Ù„Ø¨Ø§Øª Ø§Ù„ØªØ£Ù‡Ù„ Ù„ÙˆØ¸ÙŠÙØ© [Ø§ÙƒØªØ¨ Ø§Ù„Ù…Ø³Ù…Ù‰ Ø§Ù„ÙˆØ¸ÙŠÙÙŠ Ù‡Ù†Ø§]ØŸ Ø£Ø°ÙƒØ± Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©ØŒ Ø§Ù„Ø®Ø¨Ø±Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©ØŒ Ø§Ù„Ø´Ù‡Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©ØŒ ÙˆØ§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©.';
            const en = 'What are the qualification requirements for the role of [job title]? List core skills, required experience, recommended certifications, and suggested practical projects.';
            messageEl.value = currentLanguage.startsWith('ar') ? ar : en;
            // Auto-send the request
            sendMessage();
        });
    }
    if (menuTopJobs && messageEl) {
        menuTopJobs.addEventListener('click', () => {
            const ar = 'Ù…Ø§ Ù‡ÙŠ Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø£ÙƒØ«Ø± Ø·Ù„Ø¨Ù‹Ø§ Ø­Ø§Ù„ÙŠÙ‹Ø§ ÙÙŠ Ù…Ø¬Ø§Ù„ [Ø§ÙƒØªØ¨ Ø§Ù„Ù…Ø¬Ø§Ù„ Ù…Ø«Ù„: ØªØ·ÙˆÙŠØ± Ø§Ù„ÙˆÙŠØ¨ / Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ]ØŸ ÙˆÙ…Ø§ Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© ÙˆØ®Ø±ÙŠØ·Ø© Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ù…Ø®ØªØµØ±Ø© Ù„ÙƒÙ„ ÙˆØ¸ÙŠÙØ©ØŸ';
            const en = 'What are the most in-demand jobs right now in the field of [e.g., web development / AI]? Include required skills and a brief learning path for each role.';
            messageEl.value = currentLanguage.startsWith('ar') ? ar : en;
            // Auto-send the request
            sendMessage();
        });
    }
    
    // Language change handler
    if (languageSelect) {
        languageSelect.addEventListener('change', (e) => {
            currentLanguage = e.target.value;
            if (recognition) {
                recognition.lang = currentLanguage;
            }
            
            // Update HTML direction for RTL/LTR
            const html = document.documentElement;
            const welcomeText = document.getElementById('welcomeText');
            const user = JSON.parse(localStorage.getItem('user') || '{}');
            
            if (currentLanguage.startsWith('ar')) {
                html.setAttribute('dir', 'rtl');
                html.setAttribute('lang', 'ar');
                messageEl.placeholder = 'Ø§Ø³Ø£Ù„Ù†ÙŠ Ø¹Ù† Ø§Ù„Ù…Ù‡Ø§Ø±Ø§ØªØŒ Ø§Ù„ÙˆØ¸Ø§Ø¦ÙØŒ Ø£Ùˆ Ø§Ù„ØªØ­Ø¶ÙŠØ± Ù„Ù„Ù…Ù‚Ø§Ø¨Ù„Ø§Øª...';
                sendBtn.textContent = 'Ø¥Ø±Ø³Ø§Ù„';
                speechBtn.title = 'Ø¥Ø¯Ø®Ø§Ù„ ØµÙˆØªÙŠ';
                if (logoutBtn) {
                    logoutBtn.textContent = 'ğŸšª Ø®Ø±ÙˆØ¬';
                    logoutBtn.title = 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬';
                }
                if (welcomeText && user.username) {
                    welcomeText.innerHTML = `Ù…Ø±Ø­Ø¨Ø§Ù‹ØŒ <strong id="username">${user.username}</strong>`;
                }
            } else {
                html.setAttribute('dir', 'ltr');
                html.setAttribute('lang', 'en');
                messageEl.placeholder = 'Ask me about skills, job roles, or interview preparation...';
                sendBtn.textContent = 'Send';
                speechBtn.title = 'Speech input';
                if (logoutBtn) {
                    logoutBtn.textContent = 'ğŸšª Logout';
                    logoutBtn.title = 'Logout';
                }
                if (welcomeText && user.username) {
                    welcomeText.innerHTML = `Welcome, <strong id="username">${user.username}</strong>`;
                }
            }
            
            console.log('Language changed to:', currentLanguage);
        });
    }
    
    // Display user info
    const user = JSON.parse(localStorage.getItem('user') || '{}');
    const usernameEl = document.getElementById('username');
    if (user.username && usernameEl) {
        usernameEl.textContent = user.username;
    } else {
        console.warn('No user info found in localStorage');
    }
    
    // Setup logout handler
    if (logoutBtn) {
        logoutBtn.addEventListener('click', () => {
            const confirmed = confirm(currentLanguage === 'ar-SA' ? 
                'Ù‡Ù„ ØªØ±ÙŠØ¯ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬ØŸ' : 
                'Are you sure you want to logout?'
            );
            if (confirmed) {
                localStorage.removeItem('access_token');
                localStorage.removeItem('user');
                window.location.href = '/login';
            }
        });
    }
    
    // Load chat history
    loadHistory();
    
    // Focus on message input
    if (messageEl) {
        messageEl.focus();
    }
    
    // Load voices for speech synthesis
    if ('speechSynthesis' in window) {
        // Trigger voice loading
        window.speechSynthesis.getVoices();
        
        window.speechSynthesis.onvoiceschanged = () => {
            const voices = window.speechSynthesis.getVoices();
            const arabicVoices = voices.filter(v => v.lang.startsWith('ar'));
            console.log('ğŸ¤ Available Arabic voices:', arabicVoices.length);
            arabicVoices.forEach(v => console.log(`  - ${v.name} (${v.lang})`));
            
            if (arabicVoices.length === 0) {
                console.warn('âš ï¸ No Arabic voices found. Speech output may not work correctly.');
            }
        };
        
        // Trigger the event
        window.speechSynthesis.getVoices();
    }

    // ==============================================
    // VIDEO INTERVIEW FEATURE
    // ==============================================
    const videoInterviewBtn = document.getElementById('startVideoInterview');
    const videoModal = document.getElementById('videoModal');
    const userVideo = document.getElementById('userVideo');
    const startInterviewBtn = document.getElementById('startInterview');
    const nextQuestionBtn = document.getElementById('nextQuestion');
    const endInterviewBtn = document.getElementById('endInterview');
    const interviewQuestion = document.getElementById('interviewQuestion');
    const interviewerVideo = document.getElementById('interviewerVideo');
    const interviewerPhoto = document.getElementById('interviewerPhoto');

    console.log('ğŸ” Video interview elements:', {
        btn: videoInterviewBtn,
        modal: videoModal,
        video: userVideo,
        start: startInterviewBtn,
        next: nextQuestionBtn,
        end: endInterviewBtn,
        question: interviewQuestion,
        avatarVideo: interviewerVideo,
        avatarImg: interviewerPhoto
    });

    // Interview state variables (redeclared cleanly after patch fix)
    let mediaStream = null;
    let currentQuestionIndex = 0;
    let interviewActive = false;
    // 'idle' | 'followups' | 'evaluation' | 'done'
    let interviewPhase = 'idle';
    let skillsAnswer = '';
    let jobTitleAnswer = '';
    let followUpQuestions = [];
    let followUpAnswers = [];
    let currentFollowUpIndex = 0;
    let followUpAwaitTimer = null;
    let followUpAwaitAttempts = 0;

    // Start interview directly with evaluation questions
    if (startInterviewBtn) {
        startInterviewBtn.addEventListener('click', async () => {
            console.log('ğŸ¬ Starting interview (skills question first)...');
            interviewActive = true;
            interviewPhase = 'skills';
            skillsAnswer = '';
            followUpQuestions = [];
            followUpAnswers = [];
            currentFollowUpIndex = 0;
            startInterviewBtn.style.display = 'none';
            if (nextQuestionBtn) nextQuestionBtn.style.display = 'none';

            interviewQuestion.textContent = 'ğŸ’¬ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„Ø£ÙˆÙ„: Ù…Ù‡Ø§Ø±Ø§ØªÙƒ ÙˆÙˆØ¸ÙŠÙØªÙƒ Ø§Ù„Ø­Ø§Ù„ÙŠØ©';
            const firstQuestion = 'Ø£ÙˆÙ„Ø§Ù‹: Ø­Ø¯Ø«ÙŠÙ†ÙŠ Ø¹Ù† Ù…Ù‡Ø§Ø±Ø§ØªÙƒ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ÙˆÙˆØ¸ÙŠÙØªÙƒ Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø£Ùˆ Ø§Ù„Ù…Ø³Ù…Ù‰ Ø§Ù„ÙˆØ¸ÙŠÙÙŠ Ø§Ù„Ø°ÙŠ ØªØ³ØªÙ‡Ø¯ÙÙŠÙ†Ù‡. Ù…Ø§ Ø§Ù„Ù…Ø¬Ø§Ù„ Ø§Ù„Ø°ÙŠ ØªØ¹Ù…Ù„ÙŠÙ† ÙÙŠÙ‡ØŸ';
            appendTranscript('assistant', firstQuestion);

            // Ensure clean audio state
            if (recognition) { try { recognition.stop(); } catch {} }
            if (window.speechSynthesis) { try { window.speechSynthesis.cancel(); } catch {} }

            let qs = [];
            try {
                qs = await generateFollowUpQuestions('', '');
            } catch (e) {
                console.error('Follow-up generation error on start:', e);
            }
            if (!Array.isArray(qs) || qs.length === 0) {
                console.warn('âš ï¸ Using fallback evaluation questions');
                qs = [
                    'Ù…Ø§ Ø£Ø¨Ø±Ø² Ù…Ø¤Ù‡Ù„Ø§ØªÙƒ ÙˆØ®Ø¨Ø±Ø§ØªÙƒ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªÙŠ ØªØ¯Ø¹Ù… ØªØ±Ø´Ø­Ùƒ Ù„Ù‡Ø°Ù‡ Ø§Ù„ÙˆØ¸ÙŠÙØ©ØŸ',
                    'Ø§Ø°ÙƒØ±ÙŠ Ù…Ø´Ø±ÙˆØ¹Ø§Ù‹ Ø¹Ù…Ù„ÙŠØ§Ù‹ Ø·Ø¨Ù‚ØªÙ ÙÙŠÙ‡ Ù…Ù‡Ø§Ø±Ø§ØªÙƒ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©ØŒ ÙˆÙ…Ø§ ÙƒØ§Ù†Øª Ù†ØªÙŠØ¬ØªÙ‡ØŸ',
                    'Ù…Ø§ Ø£ÙƒØ¨Ø± ØªØ­Ø¯Ù‘Ù ÙˆØ§Ø¬Ù‡ØªÙÙ‡ ÙˆÙƒÙŠÙ ØªØ¹Ø§Ù…Ù„ØªÙ Ù…Ø¹Ù‡ Ù…Ù‡Ù†ÙŠØ§Ù‹ØŸ',
                    'Ù…Ø§ Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø£Ùˆ Ø§Ù„ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„ØªÙŠ ØªØªÙ‚Ù†ÙŠÙ†Ù‡Ø§ ÙˆØªØ³ØªØ®Ø¯Ù…ÙŠÙ†Ù‡Ø§ Ø¨Ø§Ù†ØªØ¸Ø§Ù…ØŸ',
                    'ÙƒÙŠÙ ØªØªØ¹Ø§Ù…Ù„ÙŠÙ† Ù…Ø¹ Ø§Ù„Ø¹Ù…Ù„ Ø¶Ù…Ù† ÙØ±ÙŠÙ‚ ÙˆØªÙ„Ù‚ÙŠ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§ØªØŸ'
                ];
            }

            followUpQuestions = qs.slice(0, 5);
            if (!followUpQuestions.length) {
                appendTranscript('system', 'âš ï¸ Ù„Ù… ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø£Ø³Ø¦Ù„Ø© ØªÙ‚ÙŠÙŠÙ…. Ø³Ù†Ø³ØªÙ…Ø± ÙÙŠ Ù…Ø­Ø§Ø¯Ø«Ø© Ø­Ø±Ø©.');
                interviewPhase = 'idle';
                startLiveListening();
                return;
            }
            await askFollowUpQuestion(0);
        });
    }

    // Helper function to open video modal with camera
    async function openVideoModal() {
        console.log('ğŸ¥ Opening video interview modal...');
        
        // Stop any existing recognition
        if (recognition) {
            try { recognition.stop(); } catch {}
        }
        
        try {
            // Request camera access
            mediaStream = await navigator.mediaDevices.getUserMedia({ 
                video: true, 
                audio: false // use Web Speech API for mic; avoid device busy conflicts
            });
            
            // Display user's video
            userVideo.srcObject = mediaStream;
            
            // Show modal
            videoModal.classList.add('active');

            // Attempt to load a looping avatar animation video if provided later
            if (interviewerVideo) {
                // Placeholder: you can replace with a hosted looping mp4/webm clip
                // For now we keep it hidden unless a source is dynamically set
                if (!interviewerVideo.src) {
                    // Future: interviewerVideo.src = '/static/interviewer_loop.mp4';
                }
                interviewerVideo.addEventListener('error', () => {
                    interviewerVideo.hidden = true;
                    if (interviewerPhoto) interviewerPhoto.hidden = false;
                });
            }
            
            // Reset interview state completely
            currentQuestionIndex = 0;
            interviewActive = false;
            isSpeaking = false;
            
            // Reset UI
            interviewQuestion.textContent = 'Ù…Ø±Ø­Ø¨Ø§Ù‹! Ø£Ù†Ø§ Ø£Ù‰ ØªÙ‰ Ø£Ù‰ ğŸ‘‹ Ø§Ø¶ØºØ· "Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù…Ù‚Ø§Ø¨Ù„Ø©" Ù„Ù„Ø¨Ø¯Ø¡. Ù‚Ù„ "exit" Ø£Ùˆ "Ø¥ÙŠÙ‚Ø§Ù" Ù„Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø­Ø¯ÙŠØ«.';
            startInterviewBtn.style.display = 'inline-block';
            if (nextQuestionBtn) nextQuestionBtn.style.display = 'none';
            setSpeakingState(false);
            
            // Clear transcript except system message
            if (transcriptEl) {
                transcriptEl.innerHTML = '<div class="t-row system">ğŸ’¬ Ø³ÙŠØ¸Ù‡Ø± Ù‡Ù†Ø§ Ù†Øµ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©. ÙŠÙ…ÙƒÙ†Ùƒ Ù‚ÙˆÙ„ "exit" Ø£Ùˆ "Ø¥ÙŠÙ‚Ø§Ù" Ù„Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø­Ø¯ÙŠØ« ÙÙŠ Ø£ÙŠ ÙˆÙ‚Øª.</div>';
            }
            
            console.log('âœ… Camera access granted, modal ready');
            return true;
        } catch (error) {
            console.error('âŒ Camera access denied:', error);
            alert('ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ÙˆØ§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ† Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ù‚Ø§Ø¨Ù„Ø©\n\nPlease allow camera and microphone access to start the interview');
            return false;
        }
    }

    // Open video modal and request camera (regular interview)
    if (videoInterviewBtn) {
        videoInterviewBtn.addEventListener('click', async () => {
            await openVideoModal();
        });
    }

    // Open video modal and start evaluation directly
    const startEvaluationBtn = document.getElementById('startEvaluationInterview');
    console.log('ğŸ” Evaluation button found:', startEvaluationBtn);
    if (startEvaluationBtn) {
        startEvaluationBtn.addEventListener('click', async () => {
            console.log('â­ Evaluation button clicked!');
            const success = await openVideoModal();
            if (success) {
                console.log('âœ… Modal opened, auto-starting interview...');
                // Auto-click the start interview button to begin evaluation
                setTimeout(() => {
                    if (startInterviewBtn) {
                        console.log('ğŸ¬ Clicking start interview button');
                        startInterviewBtn.click();
                    } else {
                        console.error('âŒ Start interview button not found');
                    }
                }, 500);
            }
        });
    } else {
        console.error('âŒ Evaluation button not found in DOM');
    }



    // Next question (hidden in live mode, kept for future)
    if (nextQuestionBtn) {
        nextQuestionBtn.addEventListener('click', () => {
            // no-op in live mode
        });
    }

    // End interview and close modal
    if (endInterviewBtn) {
        endInterviewBtn.addEventListener('click', () => {
            closeVideoInterview();
        });
    }

    // Live listening helpers
    const transcriptEl = document.getElementById('interviewTranscript');

    function appendTranscript(role, text) {
        if (!transcriptEl) return;
        const row = document.createElement('div');
        row.className = `t-row ${role}`;
        // Prefer list rendering for assistant
        if (role === 'assistant') {
            const maybeList = createListFromText(text, currentLanguage);
            if (maybeList) {
                row.appendChild(maybeList);
            } else {
                row.textContent = sanitizeForDisplay(text);
            }
        } else {
            row.textContent = text;
        }
        transcriptEl.appendChild(row);
        transcriptEl.scrollTop = transcriptEl.scrollHeight;
    }

    function setSpeakingState(on) {
        const avatar = document.getElementById('interviewerAvatar');
        if (!avatar) return;
        if (on) {
            avatar.classList.add('speaking');
        } else {
            avatar.classList.remove('speaking');
        }
    }

    function startLiveListening() {
        console.log('ğŸ¤ startLiveListening called');
        if (!recognition) {
            console.error('âŒ No recognition object available');
            alert('Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØª ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ… ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù…ØªØµÙØ­');
            return;
        }
        
        // Stop any existing recognition first
        try { 
            recognition.stop(); 
            console.log('ğŸ›‘ Stopped existing recognition');
        } catch (e) {
            console.log('â„¹ï¸ No recognition to stop');
        }
        
        // Wait a moment then start fresh
        setTimeout(() => {
            try {
                recognition.continuous = true;
                recognition.interimResults = false;
                recognition.lang = currentLanguage;
                recognition.start();
                console.log('ğŸ§ âœ… Listening started successfully (live mode)');
                interviewQuestion.textContent = 'ğŸ™ï¸ Ø£Ø³ØªÙ…Ø¹ Ø¥Ù„ÙŠÙƒ Ø§Ù„Ø¢Ù†ØŒ ØªÙØ¶Ù„ Ø¨Ø§Ù„Ø­Ø¯ÙŠØ«.';
            } catch (e) {
                console.error('âŒ Error starting recognition:', e);
                interviewQuestion.textContent = 'âŒ Ø®Ø·Ø£ ÙÙŠ Ø¨Ø¯Ø¡ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹: ' + e.message;
            }
        }, 500); // Increased delay to 500ms
    }

    async function handleInterviewUtterance(text) {
        const spoken = text.trim();
        if (!spoken) return;
        
    // Global commands
    // Check for exit command - stop speech and restart listening
        if (spoken.toLowerCase() === 'exit' || spoken === 'Ø¥ÙŠÙ‚Ø§Ù' || spoken === 'ØªÙˆÙ‚Ù') {
            console.log('ğŸ›‘ Exit command detected, stopping speech');
            
            // Stop any ongoing speech immediately
            if (window.speechSynthesis) {
                window.speechSynthesis.cancel();
            }
            
            // Reset speaking state
            isSpeaking = false;
            setSpeakingState(false);
            
            // Show message and restart listening
            appendTranscript('system', 'â¸ï¸ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø­Ø¯ÙŠØ«. Ø¬Ø§Ù‡Ø² Ù„Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.');
            interviewQuestion.textContent = 'ğŸ™ï¸ Ø£Ø³ØªÙ…Ø¹ Ø¥Ù„ÙŠÙƒ.';
            
            setTimeout(() => {
                if (interviewActive) {
                    startLiveListening();
                }
            }, 500);
            return;
        }

        // Allow user to force evaluation when in follow-ups
        const evalNow = ['Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…','Ø§Ù„ØªÙ‚ÙŠÙŠÙ…','Ù‚ÙŠÙ‘Ù… Ø§Ù„Ø¢Ù†','Ø§Ø¨Ø¯Ø¦ÙŠ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…','evaluate now','start evaluation'];
        if (evalNow.some(k => spoken.toLowerCase() === k || spoken.includes(k))) {
            if (interviewPhase === 'followups' && followUpAnswers.length > 0) {
                appendTranscript('system', 'ğŸ” Ø¨Ø¯Ø¡ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©.');
                interviewPhase = 'evaluation';
                interviewQuestion.textContent = 'â³ Ø¬Ø§Ø±ÙŠ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª...';
                try {
                    await evaluateFollowUpAnswers();
                    interviewPhase = 'done';
                } catch (e) {
                    console.error('Evaluation error (manual):', e);
                    appendTranscript('system', 'âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªÙ‚ÙŠÙŠÙ….');
                    interviewPhase = 'idle';
                }
            } else {
                appendTranscript('system', 'â„¹ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ø¬Ø§Ø¨Ø§Øª ÙƒØ§ÙÙŠØ© Ù„Ù„ØªÙ‚ÙŠÙŠÙ… Ø¨Ø¹Ø¯.');
            }
            return;
        }
        
        // Prevent processing if already speaking, except allow follow-up answers so we don't miss them
        if (isSpeaking && interviewPhase !== 'followups') {
            console.log('âš ï¸ Still speaking, ignoring new input (non-followups phase)');
            return;
        }
        // If we're in follow-ups and TTS is still going, stop TTS to prioritize the user's answer
        if (interviewPhase === 'followups' && isSpeaking) {
            try {
                if (window.speechSynthesis) window.speechSynthesis.cancel();
            } catch {}
            isSpeaking = false;
            setSpeakingState(false);
        }

        // Phase-specific routing
        if (interviewPhase === 'skills') {
            appendTranscript('user', spoken);
            skillsAnswer = spoken;
            interviewQuestion.textContent = 'â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ÙˆØªØ­Ø¶ÙŠØ± Ø£Ø³Ø¦Ù„Ø© ØªÙ‚ÙŠÙŠÙ…...';
            try {
                const qs = await generateFollowUpQuestions(skillsAnswer, ''); // infer job title(s) from answer
                followUpQuestions = qs.slice(0, 5);
                currentFollowUpIndex = 0;
                followUpAnswers = [];
                interviewPhase = 'followups';
                if (!followUpQuestions.length) {
                    appendTranscript('system', 'âš ï¸ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† ØªÙˆÙ„ÙŠØ¯ Ø£Ø³Ø¦Ù„Ø© ØªÙ‚ÙŠÙŠÙ… ÙƒØ§ÙÙŠØ©. Ø³Ù†Ø³ØªÙ…Ø± ÙÙŠ Ù…Ø­Ø§Ø¯Ø«Ø© Ø­Ø±Ø©.');
                    interviewPhase = 'idle';
                } else {
                    await askFollowUpQuestion(currentFollowUpIndex);
                }
            } catch (e) {
                console.error('Follow-up generation error:', e);
                appendTranscript('system', 'âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø£Ø³Ø¦Ù„Ø© Ø§Ù„ØªÙ‚ÙŠÙŠÙ…. Ø³Ù†Ø³ØªÙ…Ø± ÙÙŠ Ù…Ø­Ø§Ø¯Ø«Ø© Ø­Ø±Ø©.');
                interviewPhase = 'idle';
            }
            return;
        }

        if (interviewPhase === 'jobtitle') {
            appendTranscript('user', spoken);
            jobTitleAnswer = spoken;
            interviewQuestion.textContent = 'â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ÙˆØªØ­Ø¶ÙŠØ± Ø£Ø³Ø¦Ù„Ø© ØªÙ‚ÙŠÙŠÙ…...';
            try {
                const qs = await generateFollowUpQuestions(skillsAnswer, jobTitleAnswer);
                followUpQuestions = qs.slice(0, 5);
                currentFollowUpIndex = 0;
                followUpAnswers = [];
                interviewPhase = 'followups';
                if (!followUpQuestions.length) {
                    appendTranscript('system', 'âš ï¸ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† ØªÙˆÙ„ÙŠØ¯ Ø£Ø³Ø¦Ù„Ø© ØªÙ‚ÙŠÙŠÙ… ÙƒØ§ÙÙŠØ©. Ø³Ù†Ø³ØªÙ…Ø± ÙÙŠ Ù…Ø­Ø§Ø¯Ø«Ø© Ø­Ø±Ø©.');
                    interviewPhase = 'idle';
                } else {
                    await askFollowUpQuestion(currentFollowUpIndex);
                }
            } catch (e) {
                console.error('Follow-up generation error:', e);
                appendTranscript('system', 'âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø£Ø³Ø¦Ù„Ø© Ø§Ù„ØªÙ‚ÙŠÙŠÙ…. Ø³Ù†Ø³ØªÙ…Ø± ÙÙŠ Ù…Ø­Ø§Ø¯Ø«Ø© Ø­Ø±Ø©.');
                interviewPhase = 'idle';
            }
            return;
        }

        if (interviewPhase === 'followups') {
            appendTranscript('user', spoken);
            followUpAnswers.push(spoken);
            // Keep index in sync with answers length (defensive against duplicate callbacks)
            currentFollowUpIndex = followUpAnswers.length;
            console.log(`ğŸ“ Collected follow-up answer ${currentFollowUpIndex}/${followUpQuestions.length}`);
            interviewQuestion.textContent = `âœ… ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø±Ù‚Ù… ${currentFollowUpIndex} Ù…Ù† ${followUpQuestions.length}`;
            if (followUpAnswers.length < followUpQuestions.length) {
                await askFollowUpQuestion(currentFollowUpIndex);
            } else {
                // Move to evaluation
                interviewPhase = 'evaluation';
                interviewQuestion.textContent = 'â³ Ø¬Ø§Ø±ÙŠ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª...';
                console.log('ğŸ” Triggering evaluation with payload counts:', {
                    questions: followUpQuestions.length,
                    answers: followUpAnswers.length
                });
                try {
                    await evaluateFollowUpAnswers();
                    interviewPhase = 'done';
                } catch (e) {
                    console.error('Evaluation error:', e);
                    appendTranscript('system', 'âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªÙ‚ÙŠÙŠÙ….');
                    interviewPhase = 'idle';
                }
            }
            return;
        }
        
    // Default free chat behavior
    appendTranscript('user', spoken);
    interviewQuestion.textContent = 'â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙÙƒÙŠØ± ÙˆØ§Ù„Ø±Ø¯...';

        const token = localStorage.getItem('access_token');
        if (!token) {
            window.location.href = '/login';
            return;
        }
    const prefixAr = 'Ø­ÙˆØ§Ø± Ù…Ø¨Ø§Ø´Ø±: Ø±Ø¬Ø§Ø¡Ù‹ Ù‚Ø¯Ù‘Ù… Ø¥Ø¬Ø§Ø¨Ø© Ø¹Ø±Ø¨ÙŠØ© ÙØµÙŠØ­Ø© ÙˆÙ…Ù‡Ø°Ù‘Ø¨Ø©ØŒ Ù…Ø®ØªØµØ±Ø© ÙÙŠ Ø«Ù„Ø§Ø« Ø¬Ù…Ù„ ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰ØŒ ÙˆØ¨Ø£Ø³Ù„ÙˆØ¨ Ù…Ù‡Ù†ÙŠ Ø±Ø³Ù…ÙŠ. Ø§Ù„Ø³Ø¤Ø§Ù„:\n\n';
        const prefixEn = 'Live chat: reply in max 3 short sentences, direct and casual. Question:\n\n';
        const payload = currentLanguage.startsWith('ar') ? (prefixAr + spoken) : (prefixEn + spoken);

        try {
            const resp = await fetch('/api/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({ message: payload })
            });

            if (!resp.ok) {
                const err = await resp.json().catch(() => ({}));
                throw new Error(err.detail || ('HTTP ' + resp.status));
            }
            const data = await resp.json();
            if (data.messages && data.messages.length) {
                const assistantText = data.messages[0].text || '';
                appendTranscript('assistant', assistantText);
                
                    // Speak the response and restart listening when done
                    setSpeakingState(true);
                    isSpeaking = true;
                
                    // Stop recognition while speaking
                    if (recognition) {
                        try { recognition.stop(); } catch {}
                    }
                
                    // Create speech with custom callback to restart listening
                    const cleanText = assistantText.replace(/\*\*(.*?)\*\*/g, '$1').replace(/\*(.*?)\*/g, '$1');
                    if ('speechSynthesis' in window) {
                        window.speechSynthesis.cancel();
                    
                        const utterance = new SpeechSynthesisUtterance(cleanText);
                        utterance.lang = currentLanguage;
                        utterance.rate = 0.85;
                        utterance.pitch = 1;
                        utterance.volume = 1;
                    
                        // Load Arabic voice
                        let voices = window.speechSynthesis.getVoices();
                        if (currentLanguage.startsWith('ar')) {
                            const arabicVoice = voices.find(v => v.lang.startsWith('ar'));
                            if (arabicVoice) utterance.voice = arabicVoice;
                        }
                    
                        utterance.onstart = () => {
                            isSpeaking = true;
                            setSpeakingState(true);
                            console.log('ğŸ—£ï¸ AI speaking...');
                        };
                    
                        utterance.onend = () => {
                            console.log('âœ… AI finished speaking');
                            isSpeaking = false;
                            setSpeakingState(false);
                            
                            // Restart listening after a short delay
                            setTimeout(() => {
                                console.log('ğŸ”„ Attempting to restart listening... interviewActive:', interviewActive);
                                if (interviewActive) {
                                    console.log('ğŸ“¢ Calling startLiveListening()');
                                    startLiveListening();
                                } else {
                                    console.log('âš ï¸ Interview not active, skipping restart');
                                }
                            }, 1000); // Increased delay to 1 second
                        };
                    
                        utterance.onerror = (event) => {
                            console.error('âŒ Speech error:', event.error);
                            isSpeaking = false;
                            setSpeakingState(false);
                            
                            // Always try to restart on error
                            setTimeout(() => {
                                console.log('ğŸ”„ Restarting after speech error...');
                                if (interviewActive) {
                                    startLiveListening();
                                }
                            }, 1000);
                        };
                    
                        window.speechSynthesis.speak(utterance);
                        interviewQuestion.textContent = 'ğŸ—£ï¸ Ø¬Ø§Ø±Ù Ø¥Ù„Ù‚Ø§Ø¡ Ø§Ù„Ø±Ø¯...';
                        
                        // Safety fallback: restart listening after 20 seconds if utterance callbacks don't fire
                        setTimeout(() => {
                            if (isSpeaking && interviewActive) {
                                console.warn('âš ï¸ Safety timeout: TTS took too long, forcing restart');
                                isSpeaking = false;
                                setSpeakingState(false);
                                startLiveListening();
                            }
                        }, 20000);
                    }
            } else {
                appendTranscript('system', 'âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø±Ø¯ Ù…Ù† Ø§Ù„Ø®Ø§Ø¯Ù…');
                console.log('âš ï¸ No response from server, restarting listening...');
                // No response, restart listening
                setTimeout(() => {
                    if (interviewActive) {
                        startLiveListening();
                    }
                }, 1000);
            }
        } catch (err) {
            console.error('Interview chat error:', err);
            appendTranscript('system', 'âŒ Ø®Ø·Ø£: ' + err.message);
            interviewQuestion.textContent = 'ğŸ™ï¸ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.';
        }
    }

    // Function to close video interview
    function closeVideoInterview() {
        console.log('ğŸ›‘ Closing video interview...');
        
        // Stop camera stream
        if (mediaStream) {
            mediaStream.getTracks().forEach(track => track.stop());
            mediaStream = null;
        }
        
        // Stop speech recognition
        if (recognition) {
            try { recognition.stop(); } catch {}
        }
        
        // Stop any ongoing speech
        if (window.speechSynthesis) {
            window.speechSynthesis.cancel();
        }
        
        // Hide modal
        videoModal.classList.remove('active');
        
        // Reset all state
        interviewActive = false;
        currentQuestionIndex = 0;
        isSpeaking = false;
        setSpeakingState(false);
        
        // Reset UI
        if (startInterviewBtn) startInterviewBtn.style.display = 'inline-block';
        
        console.log('âœ… Video interview closed and reset');
    }

    // Close modal when clicking outside
    if (videoModal) {
        videoModal.addEventListener('click', (e) => {
            if (e.target === videoModal) {
                closeVideoInterview();
            }
        });
    }

    // Hook into global speech recognition callbacks for live mode
    if (recognition) {
        const originalOnResult = recognition.onresult;
        recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            if (interviewActive && videoModal && videoModal.classList.contains('active')) {
                // In live mode: stop recognition to avoid duplicate triggers, then process
                try { recognition.stop(); } catch {}
                handleInterviewUtterance(transcript);
            } else {
                // Fallback to original behavior (fill message box)
                if (messageEl) messageEl.value = transcript;
                if (speechBtn) speechBtn.textContent = 'ğŸ¤';
                if (typeof originalOnResult === 'function') {
                    try { originalOnResult(event); } catch {}
                }
            }
        };

        const originalOnEnd = recognition.onend;
        recognition.onend = () => {
            console.log('ğŸ”š recognition.onend fired. interviewActive:', interviewActive, 'isSpeaking:', isSpeaking);
            
            if (interviewActive && videoModal && videoModal.classList.contains('active')) {
                // Auto-restart listening when not currently speaking (covers silence timeouts)
                setTimeout(() => {
                    console.log('â±ï¸ onend timeout fired. Checking conditions...');
                    console.log('   interviewActive:', interviewActive);
                    console.log('   isSpeaking:', isSpeaking);
                    
                    if (interviewActive && !isSpeaking) {
                        console.log('ğŸ”„ Conditions met, restarting recognition...');
                        try {
                            recognition.continuous = true;
                            recognition.interimResults = false;
                            recognition.lang = currentLanguage;
                            recognition.start();
                            console.log('âœ… Recognition restarted from onend');
                            if (interviewQuestion) interviewQuestion.textContent = 'ğŸ™ï¸ Ø£Ø³ØªÙ…Ø¹ Ø¥Ù„ÙŠÙƒ.';
                        } catch (e) {
                            console.error('âŒ Failed to restart recognition:', e);
                            if (interviewQuestion) interviewQuestion.textContent = 'âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„: ' + e.message;
                        }
                    } else {
                        console.log('â¸ï¸ Not restarting - speaking:', isSpeaking, 'or interview inactive:', !interviewActive);
                    }
                }, 800); // Increased delay
            } else {
                if (speechBtn) speechBtn.textContent = 'ğŸ¤';
                if (typeof originalOnEnd === 'function') {
                    try { originalOnEnd(); } catch {}
                }
            }
        };

        // Add error handler
        recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            if (interviewActive && videoModal && videoModal.classList.contains('active')) {
                if (event.error === 'no-speech') {
                    console.log('No speech detected, continuing...');
                    interviewQuestion.textContent = 'ğŸ™ï¸ Ù„Ù… Ø£Ù„ØªÙ‚Ø· Ø£ÙŠ ØµÙˆØªØŒ ØªÙØ¶Ù„ Ø¨Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.';
                } else if (event.error === 'aborted') {
                    console.log('Recognition aborted');
                } else {
                    interviewQuestion.textContent = 'âš ï¸ Ø®Ø·Ø£: ' + event.error;
                }
            }
        };
    }

    console.log('âœ¨ Video interview initialized');
});

// =====================
// Interview helpers
// =====================

async function generateFollowUpQuestions(skillsText, jobTitleText) {
    const token = localStorage.getItem('access_token');
    if (!token) throw new Error('No token');

    const systemAr = `Ø£Ù†Øª Ù…ÙÙ‚ÙŠÙÙ‘Ù… Ù…Ù‚Ø§Ø¨Ù„Ø§Øª Ù…Ø­ØªØ±Ù. Ø§Ø³ØªÙ†Ø§Ø¯Ø§Ù‹ Ø¥Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø±Ø´Ù‘Ø­:
Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª:
"""
${skillsText}
"""
Ø§Ù„Ù…Ø³Ù…Ù‰ Ø§Ù„ÙˆØ¸ÙŠÙÙŠ Ø§Ù„Ù…Ù‚ØªØ±Ø­:
"""
${jobTitleText}
"""
Ø¥Ù† ÙƒØ§Ù† Ø§Ù„Ù…Ø³Ù…Ù‰ Ø§Ù„ÙˆØ¸ÙŠÙÙŠ ØºÙŠØ± Ù…Ø°ÙƒÙˆØ± Ø£Ùˆ ÙØ§Ø±ØºØ§Ù‹ØŒ Ø§Ø³ØªÙ†ØªÙØ¬ Ù…Ø³Ù…Ù‘Ù‰ ÙˆØ¸ÙŠÙÙŠØ§Ù‹ Ù…Ù†Ø§Ø³Ø¨Ø§Ù‹ Ù…Ù† Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª ÙˆØ§Ù„Ø®Ø¨Ø±Ø§Øª Ø£Ø¹Ù„Ø§Ù‡ØŒ Ø«Ù… Ø£Ù†Ø´Ø¦ 5 Ø£Ø³Ø¦Ù„Ø© ØªÙ‚ÙŠÙŠÙ… Ø¯Ù‚ÙŠÙ‚Ø© ØªÙ‚ÙŠØ³ Ù…Ù„Ø§Ø¡Ù…Ø© Ø§Ù„Ù…Ø±Ø´Ø­ Ù„Ø°Ù„Ùƒ Ø§Ù„Ù…Ø³Ù…Ù‰ Ø§Ù„ÙˆØ¸ÙŠÙÙŠ. Ø±ÙƒÙ‘Ø² Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø¨Ø±Ø© Ø§Ù„Ø¹Ù…Ù„ÙŠØ©ØŒ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠØŒ ÙˆØ§Ù„Ù…ÙˆØ§Ù‚Ù Ø§Ù„Ø³Ù„ÙˆÙƒÙŠØ©ØŒ ÙˆØ¨ØµÙŠØ§ØºØ© Ø¹Ø±Ø¨ÙŠØ© ÙØµØ­Ù‰ Ø±Ø³Ù…ÙŠØ© ÙˆÙ…Ù‡Ù†ÙŠØ©.
Ø£Ø±Ø¬ÙØ¹ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø¨ØµÙŠØºØ© JSON ÙÙ‚Ø· Ø¯ÙˆÙ† Ø£ÙŠ Ø´Ø±Ø­ Ø¥Ø¶Ø§ÙÙŠ Ø¨Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„ØªØ§Ù„ÙŠ:
{"questions": ["Ø³Ø¤Ø§Ù„ 1","Ø³Ø¤Ø§Ù„ 2","Ø³Ø¤Ø§Ù„ 3","Ø³Ø¤Ø§Ù„ 4","Ø³Ø¤Ø§Ù„ 5"]}`;

    const resp = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
        body: JSON.stringify({ message: systemAr })
    });
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    const data = await resp.json();
    const text = (data.messages && data.messages[0] && data.messages[0].text) || '';
    try {
        const parsed = JSON.parse(extractJson(text));
        if (parsed && Array.isArray(parsed.questions)) return parsed.questions;
    } catch (e) {
        console.warn('JSON parse failed for follow-ups, attempting line extraction');
        const lines = text.split(/\r?\n/).map(s => s.replace(/^[-*â€¢\d\.)\s]+/, '').trim()).filter(Boolean);
        return lines.slice(0, 5);
    }
    return [];
}

async function askFollowUpQuestion(index) {
    if (!Array.isArray(followUpQuestions) || index >= followUpQuestions.length) return;
    const q = followUpQuestions[index];
    appendTranscript('assistant', q);
    interviewQuestion.textContent = 'ğŸ’¬ Ø³Ø¤Ø§Ù„ Ù…ØªØ§Ø¨Ø¹Ø© (' + (index + 1) + '/' + followUpQuestions.length + ')';

    // Clear any existing wait timer
    if (followUpAwaitTimer) {
        clearTimeout(followUpAwaitTimer);
        followUpAwaitTimer = null;
    }
    followUpAwaitAttempts = 0;

    // Set a watchdog timer: if no new answer arrives in 60s, re-ask
    followUpAwaitTimer = setTimeout(() => {
        if (interviewPhase === 'followups' && followUpAnswers.length === index) {
            followUpAwaitAttempts += 1;
            const retryMsg = 'ğŸ” Ù„Ù… ÙŠØªÙ… Ø±ØµØ¯ Ø¥Ø¬Ø§Ø¨Ø©ØŒ Ø¥Ø¹Ø§Ø¯Ø© Ø·Ø±Ø­ Ø§Ù„Ø³Ø¤Ø§Ù„: ' + q;
            appendTranscript('system', retryMsg);
            console.log('â° Follow-up watchdog fired. attempt=', followUpAwaitAttempts);
            // Re-speak question
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const utter = new SpeechSynthesisUtterance(q);
                utter.lang = currentLanguage;
                utter.onend = () => { setTimeout(() => { if (interviewActive) startLiveListening(); }, 500); };
                utter.onerror = () => { setTimeout(() => { if (interviewActive) startLiveListening(); }, 500); };
                window.speechSynthesis.speak(utter);
            }
        }
    }, 60000);

    // Speak and resume listening using the same TTS pipeline used for assistant
    if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(q);
        utterance.lang = currentLanguage;
        utterance.rate = 0.9;
        utterance.pitch = 1;
        let voices = window.speechSynthesis.getVoices();
        if (currentLanguage.startsWith('ar')) {
            const arV = voices.find(v => v.lang.startsWith('ar'));
            if (arV) utterance.voice = arV;
        }
        utterance.onstart = () => { isSpeaking = true; setSpeakingState(true); };
        utterance.onend = () => {
            isSpeaking = false; setSpeakingState(false);
            setTimeout(() => { if (interviewActive) startLiveListening(); }, 800);
        };
        utterance.onerror = () => {
            isSpeaking = false; setSpeakingState(false);
            setTimeout(() => { if (interviewActive) startLiveListening(); }, 800);
        };
        window.speechSynthesis.speak(utterance);
    }
}

async function evaluateFollowUpAnswers() {
    const token = localStorage.getItem('access_token');
    if (!token) throw new Error('No token');

    const payload = {
        questions: followUpQuestions,
        answers: followUpAnswers
    };
    const instrAr = `Ø£Ù†Øª Ù…ÙÙ‚ÙŠÙÙ‘Ù… Ù…Ù‚Ø§Ø¨Ù„Ø§Øª. Ù‚ÙŠÙ‘ÙÙ… Ù…Ø¯Ù‰ Ù…ÙÙ„Ø§Ø¡Ù…Ø© ÙƒÙ„ Ø¥Ø¬Ø§Ø¨Ø© Ù„Ø³Ø¤Ø§Ù„Ù‡Ø§ (ØªØ´Ø§Ø¨Ù‡ Ø§Ù„Ù…Ø¹Ù†Ù‰ ÙˆØ§Ù„Ø¯Ù‚Ø© Ø§Ù„Ù…Ù‡Ù†ÙŠØ©) Ø¨Ø¯Ø±Ø¬Ø© Ù…Ù† 1 Ø¥Ù„Ù‰ 10ØŒ Ø­ÙŠØ« 1 = ØªØ´Ø§Ø¨Ù‡ Ø¶Ø¹ÙŠÙ Ø¬Ø¯Ø§Ù‹ØŒ 10 = ØªØ´Ø§Ø¨Ù‡ Ø¹Ø§Ù„Ù Ø¬Ø¯Ø§Ù‹.
Ø£Ø±Ø¬ÙØ¹ JSON ÙÙ‚Ø· Ø¨Ø§Ù„Ø´ÙƒÙ„:
{"scores":[{"question":"...","answer":"...","score":7,"justification":"Ø³Ø¨Ø¨ Ù…Ø®ØªØµØ±"},...],"average":7.2}`;

    const message = instrAr + '\n\nØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:\n' + JSON.stringify(payload, null, 2);
    const resp = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
        body: JSON.stringify({ message })
    });
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    const data = await resp.json();
    const text = (data.messages && data.messages[0] && data.messages[0].text) || '';
    let result = null;
    try {
        result = JSON.parse(extractJson(text));
    } catch (e) {
        console.warn('Evaluation JSON parse failed, raw text shown');
        appendTranscript('system', 'Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªÙ‚ÙŠÙŠÙ… (Ù†Øµ Ø®Ø§Ù…):\n' + text);
        return;
    }

    if (!result || !Array.isArray(result.scores)) {
        appendTranscript('system', 'âš ï¸ ØªØ¹Ø°Ø± ØªÙØ³ÙŠØ± Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªÙ‚ÙŠÙŠÙ….');
        return;
    }

    // Render scores
    let lines = result.scores.map((s, i) => `${i+1}. Ø§Ù„Ø¯Ø±Ø¬Ø©: ${s.score}/10 â€” ${sanitizeForDisplay(s.justification || '')}`);
    appendTranscript('assistant', 'Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…:\n' + lines.join('\n'));

    const avg = typeof result.average === 'number' ? result.average : (result.scores.reduce((a, s) => a + (s.score || 0), 0) / result.scores.length);
    const summary = `Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¹Ø§Ù…: ${avg.toFixed(1)} Ù…Ù† 10. Ø£Ø­Ø³Ù†ØªÙØŒ ÙˆØ³Ø£Ù‚ØªØ±Ø­ ØªØ­Ø³ÙŠÙ†Ø§Øª ÙÙŠ Ø§Ù„Ù†Ù‚Ø§Ø· Ø°Ø§Øª Ø§Ù„Ø¯Ø±Ø¬Ø§Øª Ø§Ù„Ø£Ù‚Ù„.`;
    appendTranscript('assistant', summary);

    // Speak summary
    setSpeakingState(true);
    if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(summary);
        utterance.lang = currentLanguage;
        let voices = window.speechSynthesis.getVoices();
        if (currentLanguage.startsWith('ar')) {
            const arV = voices.find(v => v.lang.startsWith('ar'));
            if (arV) utterance.voice = arV;
        }
        utterance.onstart = () => { isSpeaking = true; setSpeakingState(true); };
        utterance.onend = () => { isSpeaking = false; setSpeakingState(false); setTimeout(() => { if (interviewActive) startLiveListening(); }, 800); };
        utterance.onerror = () => { isSpeaking = false; setSpeakingState(false); setTimeout(() => { if (interviewActive) startLiveListening(); }, 800); };
        window.speechSynthesis.speak(utterance);
    }
}

// Safely extract first JSON block from a text that may contain prose
function extractJson(text) {
    const start = text.indexOf('{');
    const end = text.lastIndexOf('}');
    if (start !== -1 && end !== -1 && end > start) {
        return text.slice(start, end + 1);
    }
    return text; // fallback
}
